# Equation Expansion for Simple Functions

The core concept behind this approach is found in [Quantum Annealing for Prime Factorization](https://www.nature.com/articles/s41598-018-36058-z). Solutions to the problem are found using least-squares. 

For the problem N = p\*q, the annealer would solve min((N-p\*q)^2). Constants can be replaced ordinarily. If N = 3, then we solve min((3-p\*q)<sup>2</sup>). The remaining variables are then put in their binary representations. For n bits per variable, each variable x would be represented as x = -2<sup>n</sup>x<sub>n</sub>+2<sup>n-1</sup>x<sub>n-1</sub>+2<sup>n-2</sup>x<sub>n-2</sub>+...+x<sub>0</sub> allowing it to cover -2<sup>n-1</sup> <= x <= 2<sup>n-1</sup>-1. Our previous problem then becomes min((3-(-2<sup>n</sup>p<sub>n</sub>+2<sup>n-1</sup>p<sub>n-1</sub>+...+p<sub>0</sub>)\*(-2<sup>n</sup>q<sub>n</sub>+2<sup>n-1</sup>q<sub>n-1</sub>+...+q<sub>0</sub>))<sup>2</sup>). Now that all the variables in the problem are binary, we can expand and quadritize the equation. This process reduces all terms with 2 or more variables down to 2 variables according to the methods described in [Pseudo-Bolean Optimization](https://www.sciencedirect.com/science/article/pii/S0166218X01003419). Now that the formulation is friendly for a binary quadratic model, we can use the coefficients of each of the terms as our couplings and biases. After this, our BQM preprocessing is complete and we can use DWave's annealing tools to find a solution. 

The two programs in this subproject, [factoring_test](factoring_test.py) and [linear_fit](linear_fit.py) both use this method to generate solutions for their given problem. 
